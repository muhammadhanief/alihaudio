{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///D:/2026/SID/Sistem%20Informasi/inialihaudio/alihaudio/app/api/auth/session/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\r\nimport { cookies } from \"next/headers\";\r\n\r\nexport const dynamic = \"force-dynamic\";\r\n\r\nexport async function GET() {\r\n    try {\r\n        const cookieStore = await cookies();\r\n        const session = cookieStore.get(\"auth_session\");\r\n\r\n        if (!session) {\r\n            return NextResponse.json({ error: \"No session found\" }, { status: 401 });\r\n        }\r\n\r\n        let userData;\r\n        try {\r\n            userData = JSON.parse(session.value);\r\n        } catch (e) {\r\n            return NextResponse.json({ error: \"Invalid session format\" }, { status: 401 });\r\n        }\r\n\r\n        const nipp = userData.nipp || userData.username || userData.nip;\r\n\r\n        // Fetch CURRENT role from DB to ensure UI is always in sync\r\n        try {\r\n            const pool = (await import(\"@/lib/db\")).default;\r\n            const [dbUser]: any = await pool.query(\"SELECT role FROM users WHERE nipp = ?\", [nipp]);\r\n\r\n            if (dbUser.length > 0 && dbUser[0].role !== userData.role) {\r\n                userData.role = dbUser[0].role;\r\n\r\n                // Update the cookie so other parts of the app (Server Components/Middleware)\r\n                // will also see the updated role immediately.\r\n                cookieStore.set(\"auth_session\", JSON.stringify(userData), {\r\n                    httpOnly: true,\r\n                    secure: process.env.NODE_ENV === \"production\",\r\n                    sameSite: \"lax\",\r\n                    path: \"/alihaudio\",\r\n                    maxAge: 60 * 60 * 24, // 24 hours\r\n                });\r\n            }\r\n        } catch (dbErr) {\r\n            console.error(\"Session Role Sync Error:\", dbErr);\r\n        }\r\n\r\n        const response = NextResponse.json({\r\n            authenticated: true,\r\n            user: userData\r\n        });\r\n\r\n        // Anti-cache headers for cPanel/LiteSpeed\r\n        response.headers.set('Cache-Control', 'no-store, no-cache, must-revalidate, proxy-revalidate');\r\n        response.headers.set('Pragma', 'no-cache');\r\n        response.headers.set('Expires', '0');\r\n\r\n        return response;\r\n    } catch (error) {\r\n        console.error(\"Session Check Error:\", error);\r\n        const errResponse = NextResponse.json({ error: \"Unauthorized\" }, { status: 401 });\r\n        errResponse.headers.set('Cache-Control', 'no-store, no-cache, must-revalidate');\r\n        return errResponse;\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;AAEO,MAAM,UAAU;AAEhB,eAAe;IAClB,IAAI;QACA,MAAM,cAAc,MAAM,IAAA,4IAAO;QACjC,MAAM,UAAU,YAAY,GAAG,CAAC;QAEhC,IAAI,CAAC,SAAS;YACV,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAmB,GAAG;gBAAE,QAAQ;YAAI;QAC1E;QAEA,IAAI;QACJ,IAAI;YACA,WAAW,KAAK,KAAK,CAAC,QAAQ,KAAK;QACvC,EAAE,OAAO,GAAG;YACR,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAyB,GAAG;gBAAE,QAAQ;YAAI;QAChF;QAEA,MAAM,OAAO,SAAS,IAAI,IAAI,SAAS,QAAQ,IAAI,SAAS,GAAG;QAE/D,4DAA4D;QAC5D,IAAI;YACA,MAAM,OAAO,CAAC,2FAAwB,EAAE,OAAO;YAC/C,MAAM,CAAC,OAAO,GAAQ,MAAM,KAAK,KAAK,CAAC,yCAAyC;gBAAC;aAAK;YAEtF,IAAI,OAAO,MAAM,GAAG,KAAK,MAAM,CAAC,EAAE,CAAC,IAAI,KAAK,SAAS,IAAI,EAAE;gBACvD,SAAS,IAAI,GAAG,MAAM,CAAC,EAAE,CAAC,IAAI;gBAE9B,6EAA6E;gBAC7E,8CAA8C;gBAC9C,YAAY,GAAG,CAAC,gBAAgB,KAAK,SAAS,CAAC,WAAW;oBACtD,UAAU;oBACV,QAAQ,oDAAyB;oBACjC,UAAU;oBACV,MAAM;oBACN,QAAQ,KAAK,KAAK;gBACtB;YACJ;QACJ,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,4BAA4B;QAC9C;QAEA,MAAM,WAAW,gJAAY,CAAC,IAAI,CAAC;YAC/B,eAAe;YACf,MAAM;QACV;QAEA,0CAA0C;QAC1C,SAAS,OAAO,CAAC,GAAG,CAAC,iBAAiB;QACtC,SAAS,OAAO,CAAC,GAAG,CAAC,UAAU;QAC/B,SAAS,OAAO,CAAC,GAAG,CAAC,WAAW;QAEhC,OAAO;IACX,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,wBAAwB;QACtC,MAAM,cAAc,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAe,GAAG;YAAE,QAAQ;QAAI;QAC/E,YAAY,OAAO,CAAC,GAAG,CAAC,iBAAiB;QACzC,OAAO;IACX;AACJ"}}]
}